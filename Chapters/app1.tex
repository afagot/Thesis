\graphicspath{{chapt_dutch/}{intro/}{chapt2/}{chapt3/}{chapt4/}{chapt5/}{chapt6/}{chapt7/}}

% Header
\renewcommand\evenpagerightmark{{\scshape\small Appendix A}}
\renewcommand\oddpageleftmark{{\scshape\small A data acquisition software for VME CAEN TDCs}}

\renewcommand{\bibname}{References}

\hyphenation{}

\chapter[A data acquisition software for CAEN VME TDCs]%
{A data acquisition software for CAEN VME TDCs}
\label{app1}

Certifying detectors in the perspective of HL-LHC required to develop tools for the GIF++ experiment. Among them was the C++ \acf{DAQ} software that allows to make the communications in between the computer and the TDC modules in order to retrieve the RPC data~\cite{GIFDAQ}. In this appendix, details about the software, as of how the software was written, how it functions and how it can be exported to another similar setup.

\section{GIF++ DAQ file tree}
\label{app1:sec:code}

	GIF++ DAQ source code is fully available on github at \url{https://github.com/afagot/GIF_DAQ}. The software requires 3 non-optional dependencies:

	\begin{itemize}
		\item[•] \href{http://www.caen.it/csite/CaenProd.jsp?idmod=417&parent=11}{CAEN USB Driver} to mount the VME hardware
		\item[•] \href{http://www.caen.it/csite/CaenProd.jsp?idmod=689&parent=38}{CAEN VME Library} to communicate with the VME hardware
		\item[•] \href{https://root.cern.ch/downloading-root}{ROOT} to organize the collected data into a TTree
	\end{itemize}

	The CAEN VME library will not be packaged by distributions and will need to be installed manually. To compile the GIF++ DAQ project via a terminal, from the DAQ folder use the command :

	\begin{minted}[bgcolor=bg,fontsize=\footnotesize]{bash}
	make
	\end{minted}

	The source code tree is provided below along with comments to give an overview of the files' content. The different objects created for this project (\cppinline{v1718}, \cppinline{v1190a}, \cppinline{IniFile} \& \cppinline{DataReader}) will be described in details in the following sections.\\

	\dirtree{%
	 .1 GIF\_DAQ.
	 .2 bin.
	 .3 daq\DTcomment{executable}.
	 .2 include\DTcomment{list of C++ header files}.
	 .3 CAENVMElib.h\DTcomment{CAEN C++ libs}.
	 .3 CAENVMEoslib.h\DTcomment{CAEN OS C++ libs}.
	 .3 CAENVMEtypes.h\DTcomment{CAEN variables}.
	 .3 DataReader.h\DTcomment{declaration of object DataReader}.
	 .3 IniFile.h\DTcomment{declaration of object IniFile for ini parser}.
	 .3 MsgSvc.h\DTcomment{declaration of DAQ log messages}.
	 .3 utils.h\DTcomment{declaration of useful variables and comm. functions}.
	 .3 v1190a.h\DTcomment{declaration of object v1190a}.
	 .3 v1718.h\DTcomment{declaration of object v1718}.
	 .2 lib\DTcomment{CAEN library}.
	 .3 install.
	 .3 x86.
	 .4 libCAENVME.so.2.41.
	 .2 obj\DTcomment{binary file created by compiler}.
	 .3 ....
	 .2 src\DTcomment{list of C++ source files}.
	 .3 daq.cxx\DTcomment{main file}.
	 .3 DataReader.cxx\DTcomment{definition of DataReader's methods}.
	 .3 IniFile.cxx\DTcomment{definition of IniFile's methods}.
	 .3 MsgSvc.cxx\DTcomment{definition of log messaging functions}.
	 .3 utils.cxx\DTcomment{definition of useful communication functions}.
	 .3 v1190a.cxx\DTcomment{declaration of v1190a's methods}.
	 .3 v1718.cxx\DTcomment{declaration of v1718's methods}.
	 .2 makefile\DTcomment{compiler instructions}.
	 .2 README.md\DTcomment{REAMDE file for github}.
	}

\section{Description of the readout setup}
\label{app1:sec:setup}

    The CMS RPC setup at GIF++ counts 5 V1190A \acf{TDC} manufactured by CAEN~\cite{V1190AMUT}. V1190A are VME units accepting 128 independent Multi-Hit/Multi-Event TDC channels whose signals are treated by 4 \SI{100}{ps} high performance TDC chips developped by CERN / ECP-MIC Division. The communication between the computer and the TDCs to transfer data is done via a V1718 VME master module also manufactured by CAEN and operated from a USB port~\cite{V1718MUT}. These VME modules are all hosted into a 6U VME 6021 powered crate manufactured by W-Ie-Ne-R than can accomodate up to 21 VME bus cards~\cite{6U6000MUT}. These 3 components of the DAQ setup are shown in Figure~\ref{fig:DAQSetup}.\\
    
    \begin{figure}[H]
    \hspace{-15mm}
        \begin{subfigure}{0.1\linewidth}
		    \centering
			\includegraphics[height = 10cm]{fig/app1/V1190A-front.pdf}
			\caption{\label{fig:DAQSetup:A}}
		\end{subfigure}
		\begin{subfigure}{0.25\linewidth}
		    \centering
			\includegraphics[height = 10cm]{fig/app1/V1718-front.pdf}
			\caption{\label{fig:DAQSetup:B}}
		\end{subfigure}
		\begin{subfigure}{0.65\linewidth}
		    \centering
			\includegraphics[width = \plotwidth]{fig/app1/Wiener-front.png}
			\caption{\label{fig:DAQSetup:C}}
		\end{subfigure}
		\caption{\label{fig:DAQSetup} (\ref{fig:DAQSetup:A}) View of the front panel of a V1190A TDC module~\cite{V1190AMUT}. (\ref{fig:DAQSetup:B}) View of the front panel of a V1718 Bridge module~\cite{V1718MUT}. (\ref{fig:DAQSetup:C}) View of the front panel of a 6U 6021 VME crate~\cite{6U6000MUT}.}
	\end{figure}

\section{Data read-out}
\label{app1:sec:Data}

	To efficiently perform a data readout algorithm, C++ objects to handle the VME modules (TDCs and VME bridge) have been created along with objects to store data and read the configuration file that comes as an input of the DAQ software.\\
	It is useful to remind that the DAQ software in GIF++ is not a standalone software but is called through a \acf{webDCS} application, that is the core of interactions with GIF++ setup, when data needs to be taken. Nevertheless, it is straight forward to make it into a standalone program that could be adapted to any VME setup using V1190A and V1718 modules.\\

    \subsection{V1190A TDCs}
    \label{app1:ssec:V1190A}

	The DAQ used at GIF takes profit of the \textit{Trigger Matching Mode} offered by V1190A modules. This setting is enabled through the method \cppinline{v1190a::SetTrigMatching (int ntdcs)} where \cppinline{ntdcs} is the total number of TDCs in the setup this setting needs to be enabled for (Source Code~\ref{cpp:v1190a}). A trigger matching is performed in between a trigger time tag, a trigger signal sent into the TRIGGER input of the TDC visible on Figure~\ref{fig:DAQSetup:A}, and the channel time measurements, signals recorded from the detectors under test in our case. Control over this data acquisition mode, explained through Figure~\ref{fig:V1190A-TMM}, is offered via 4 programmable parameters:
        
	\begin{itemize}
		\item \textbf{match window:} the matching between a trigger and a hit is done within a programmable time window. This is set via the method\\ \cppinline{void v1190a::SetTrigWindowWidth(Uint windowWidth,int ntdcs)}
		\item \textbf{window offset:} temporal distance between the trigger tag and the start of the trigger matching window. This is set via the method\\ \cppinline{void v1190a::SetTrigWindowWidth(Uint windowWidth,int ntdcs)}
		\item \textbf{extra search margin:} an extended time window is used to ensure that all matching hits are found. This is set via the method\\ \cppinline{void v1190a::SetTrigSearchMargin(Uint searchMargin,int ntdcs)}
		\item \textbf{reject margin:} older hits are automatically rejected to preven buffer overflows and to speed up the search time. This is set via the method\\ \cppinline{void v1190a::SetTrigRejectionMargin(Uint rejectMargin,int ntdcs)}
	\end{itemize}
    
    \begin{figure}[H]
		\centering
		\includegraphics[width = 1.25\plotwidth]{fig/app1/V1190A-TMM.pdf}\\
		\caption{\label{fig:V1190A-TMM} Module V1190A \textit{Trigger Matching Mode} timing diagram~\cite{V1190AMUT}.}
	\end{figure}
	
	Each of these 4 parameters are given in number of clocks, \SI{1}{clock} being \SI{25}{ns} long. It is easy to understand at this level that there are 3 possible functionning settings:
        
	\begin{itemize}
		\item \textbf{1:} the match window is entirely contained after the trigger signal,
		\item \textbf{2:} the match window overlaps the trigger signal, or
		\item \textbf{3:} the match window is entirely contained before the trigger signal as displayed on Figure~\ref{fig:V1190A-TMM}.
	\end{itemize}
	
	In both the first and second cases, the sum of the window width and of the offset can be set to a maximum of \SI{40}{clocks}, which corresponds to \SI{1}{\micro s}. Evidently, the offset can be negative, allowing for a longer match window, with the constraint of having the window ending at most \SI{1}{\micro s} after the trigger signal. In the third case, the maximum negative offset allowed is of \SI{2048}{clocks} (12 bit) corresponding to \SI{51.2}{\micro s}, the match window being strictly smaller than the offset. In the case of GIF++, the choice has been made to use this last setting by delaying the trigger signal. During the studies performed in GIF++, both the efficiency of the RPCs, probed using a muon beam, and the noise or gamma background rate are monitored. The extra search and reject margins are left unused.\\
	To probe the efficiency of RPC detectors, the trigger time tag is provided by the coïncidence of scintillators when a bunch of muons passes through GIF++ area is used to trigger the data acquisition. For this measurement, it is useful to reduce the match window width only to contain the muon information. Indeed, the delay in between a trigger signal and the detection of the corresponding muon in the RPC being very contant (typically a few tens of ns due to jitter and cable length), the muon signals are very localised in time. Thus, due to a delay of approximalety \SI{325}{ns} in between the muons and the trigger, the settings where chosen to have a window width of \SI{24}{clocks} (\SI{600}{ns}) centered on the muon peak thanks to a negative offset of \SI{29}{clocks} (\SI{725}{ns}).\\
	On the otherhand, monitoring the rates don't require for the DAQ to look at a specific time window. It is important to integrate enough time to have a robust measurement of the rate as the number of hits per time unit. The triggerring signal is provided by a pulse generator at a frequency of \SI{300}{Hz} to ensure that the data taking occurs in a random way, with respect to beam physics, to probe only the irradiation spectrum on the detectors. The match window is set to \SI{400}{clocks} (\SI{10}{\micro s}) and the negative offset to \SI{401}{clocks} as it needs to exceed the value of the match window.\\
	
	\begin{code}
	\captionof{listing}{Description of C++ object \cppinline{v1190a}.}
	\label{cpp:v1190a}
	
    \begin{cppcode}
class v1190a
{
 private :
    long              Handle;
    vector<Data32>    Address;
    CVDataWidth       DataWidth;
    CVAddressModifier AddressModifier;

 public:

    v1190a(long handle, IniFile *inifile, int ntdcs);
    ~v1190a();
    Data16 write_op_reg(Data32 address, int code, string error);
    Data16 read_op_reg(Data32 address, string error);
    void   Reset(int ntdcs);
    void   Clear(int ntdcs);
    void   TestWR(Data16 value,int ntdcs);
    void   CheckTDCStatus(int ntdcs);
    void   CheckCommunication(int ntdcs);
    void   SetTDCTestMode(Data16 mode,int ntdcs);
    void   SetTrigMatching(int ntdcs);
    void   SetTrigTimeSubstraction(Data16 mode,int ntdcs);
    void   SetTrigWindowWidth(Uint windowWidth,int ntdcs);
    void   SetTrigWindowOffset(Uint windowOffset,int ntdcs);
    void   SetTrigSearchMargin(Uint searchMargin,int ntdcs);
    void   SetTrigRejectionMargin(Uint rejectMargin,int ntdcs);
    void   GetTrigConfiguration(int ntdcs);
    void   SetTrigConfiguration(IniFile *inifile,int ntdcs);
    void   SetTDCDetectionMode(Data16 mode,int ntdcs);
    void   SetTDCResolution(Data16 lsb,int ntdcs);
    void   SetTDCDeadTime(Data16 time,int ntdcs);
    void   SetTDCHeadTrailer(Data16 mode,int ntdcs);
    void   SetTDCEventSize(Data16 size,int ntdcs);
    void   SwitchChannels(IniFile *inifile,int ntdcs);
    void   SetIRQ(Data32 level, Data32 count,int ntdcs);
    void   SetBlockTransferMode(Data16 mode,int ntdcs);
    void   Set(IniFile *inifile,int ntdcs);
    void   CheckStatus(CVErrorCodes status) const;
    int    ReadBlockD32(Uint tdc, const Data16 address,
               Data32 *data, const Uint words, bool ignore_berr);
    Uint   Read(RAWData *DataList,int ntdcs);
};
    \end{cppcode}
    \end{code}
	
	The v1190a object, defined in the DAQ software as in Source Code~\ref{cpp:v1190a}, offers the possility to concatenate all TDCs in the readout setup into a single object containing a list of hardware addresses (addresses to access the TDCs' buffer through the VME crate) and each constructor and method acts on the list of TDCs.\\
	
	\subsection{DataReader}
	\label{app1:ssec:DataReader}
	
	Enabled thanks to \cppinline{v1190a::SetBlockTransferMode(Data16 mode, int ntdcs)}, the data transfer is done via \acf{BLT}. Using BLT allows to tranfer a fixed number of events called a \textit{block}. This is used together with an \acf{AFL} of the TDCs' output buffers, defined through \cppinline{v1190a::SetIRQ(Data32 level, Data32 count,int ntdcs)}. This AFL gives the maximum amount of 32735 words (16 bits, corresponding to the depth of a TDC output buffer) that can writen in a buffer before an \acf{IRQ} is generated and seen by the VME Bridge, stopping the data acquisition to transfer the content of each TDC buffers before resuming. For each trigger, 6 words or more are written into the TDC buffer:
	
	\begin{itemize}
		\item \textbf{a global header} providing information of the event number since the beginning of the data acquisition,
		\item \textbf{a TDC header},
		\item \textbf{the TDC data} (\textit{if any}), 1 for each hit recorded during the event, providing the channel and the time stamp associated to the hit,
		\item \textbf{a TDC error} providing error flags,
		\item \textbf{a TDC trailer},
		\item \textbf{a global trigger time tag} that provides the absolute trigger time relatively to the last reset, and
		\item \textbf{a global trailer} providing the total word count in the event.
	\end{itemize}
	
	As previously described in Section~\ref{ssec:PulseProc}, CMS RPC FEEs provide us with \SI{100}{ns} long LVDS output signals that are injected into the TDCs' input. Any avalanche signal that gives a signal above the FEEs threshold is thus recorded by the TDCs as a hit within the match window. Each hit is assigned to a specific TDC channel with a time stamp, with a precision of \SI{100}{ps}. The reference time, $t_0=0$, is provided by the beginning of the match window. Thus for each trigger, coming from a scintillator coïncidence or the pulse generator, a list of hits is stored into the TDCs' buffers and will then be transfered into a ROOT Tree.\\
	
	When the BLT is used, it is easy to understand that the maximum number of words that have been set as ALF will not be a finite number of events or, at least, the number of events that would be recorded into the TDC buffers will not be a multiple of the block size. In the last BLT cycle to tranfer data, the number of events to transfer will most propably be lower than the block size. In that case, the TDC can add fillers at the end of the block but this option requires to send more data to the computer and is thus a little slower. Another solution is to finish the transfer after the last event by sending a bus error that states that the BLT reached the last event in the pile. This method has been chosen in GIF++.\\
	
	Due to irradiation, an event in GIF++ can count up to 300 words per TDC. A limit of 4096 words (12 bits) has been set to generate IRQ which represent from 14 to almost 700 events depending on the average of hits collected per event. Then the block size has been set to 100 events with enabled bus errors. When an AFL is reached for one of the TDCs, the VME bridge stops the acquisition by sending a BUSY signal.\\
	
	The data is then transfered one TDC at a time into a structure called \cppinline{RAWData} (Source Code~\ref{cpp:rawdata}).\\
	
	\begin{code}
	\captionof{listing}{Description of data holding C++ structure \cppinline{RAWData}.}
	\label{cpp:rawdata}
	
    \begin{cppcode}
struct RAWData{
    vector<int>            *EventList;
    vector<int>            *NHitsList;
    vector<int>            *QFlagList;
    vector<vector<int> >   *ChannelList;
    vector<vector<float> > *TimeStampList;
};
    \end{cppcode}
    \end{code}
    
	In order to organize the data transfer and the data storage, an object called \cppinline{DataReader} was created (Source Code~\ref{cpp:datareader}). On one hand, it has \cppinline{v1718} and \cppinline{v1190a} objects as private members for communication purposes, such as VME modules settings via the configuration file \cppinline{*iniFile} or data read-out through \cppinline{v1190a::Read()} and on the other hand, it contains the struture \cppinline{RAWData} that allows to organise the data in vectors reproducing the tree structre of a ROOT file.\\
	
	\begin{code}
	\captionof{listing}{Description of C++ object \cppinline{DataReader}.}
	\label{cpp:datareader}
	
    \begin{cppcode}
class DataReader
{
    private:
        bool     StopFlag;
        IniFile *iniFile;
        Data32   MaxTriggers;
        v1718   *VME;
        int      nTDCs;
        v1190a  *TDCs;
        RAWData  TDCData;

    public:
        DataReader();
        virtual ~DataReader();
        void     SetIniFile(string inifilename);
        void     SetMaxTriggers();
        Data32   GetMaxTriggers();
        void     SetVME();
        void     SetTDC();
        int      GetQFlag(Uint it);
        void     Init(string inifilename);
        void     FlushBuffer();
        void     Update();
        string   GetFileName();
        void     WriteRunRegistry(string filename);
        void     Run();
};
    \end{cppcode}
    \end{code}
    
    Each event is tranferred from \cppinline{TDCData} and saved into branches of a ROOT \cppinline{TTree} as 3 integers that represent the event ID (\cppinline{EventCount}), the number of hits read from the TDCs (\cppinline{nHits}), and the quality flag that provides information for any problem in the data transfer (\cppinline{qflag}), and 2 lists of \textit{nHits} elements containing the fired TDC channels (\cppinline{TDCCh}) and their respective time stamps (\cppinline{TDCTS}), as presented in Source Code~\ref{cpp:datatranfer}. An example of ROOT data file is provided with Figure~\ref{fig:ROOTfile}.\\
    
    \begin{code}
	\captionof{listing}{Highlight of the data transfer and organisation within \cppinline{DataReader::Run()} after the data has been collected into \cppinline{TDCData}.}
	\label{cpp:datatranfer}
	
    \begin{cppcode}
RAWData TDCData;
TFile *outputFile = new TFile(outputFileName.c_str(),"recreate");
TTree *RAWDataTree = new TTree("RAWData","RAWData");

int           EventCount = -9;
int           nHits = -8;
int           qflag = -7;
vector<int>   TDCCh;
vector<float> TDCTS;

RAWDataTree->Branch("EventNumber",&EventCount, "EventNumber/I");
RAWDataTree->Branch("number_of_hits",&nHits,"number_of_hits/I");
RAWDataTree->Branch("Quality_flag",&qflag,"Quality_flag/I");
RAWDataTree->Branch("TDC_channel",&TDCCh);
RAWDataTree->Branch("TDC_TimeStamp",&TDCTS);

//...
//Here read the TDC data using v1190a::Read() and place it into
//TDCData for as long as you didn't collect the requested amount
//of data.
//...
    
for(Uint i=0; i<TDCData.EventList->size(); i++){
    EventCount  = TDCData.EventList->at(i);
    nHits       = TDCData.NHitsList->at(i);
    qflag       = TDCData.QFlagList->at(i);
    TDCCh       = TDCData.ChannelList->at(i);
    TDCTS       = TDCData.TimeStampList->at(i);
    RAWDataTree->Fill();
}
    \end{cppcode}
    \end{code}
    
    \begin{figure}[H]
		\centering
		\includegraphics[width = \plotwidth]{fig/app1/webDCS-ROOT-browser.png}
		\caption{\label{fig:ROOTfile} Structure of the ROOT output file generated by the DAQ. The 5 branches (\cppinline{EventNumber}, \cppinline{number_of_hits}, \cppinline{Quality_flag}, \cppinline{TDC_channel} and \cppinline{TDC_TimeStamp}) are visible on the left panel of the ROOT browser. On the right panel is visible the histogram corresponding to the variable \cppinline{nHits}. In this specific example, there were approximately 50k events recorded to measure the gamma irradiation rate on the detectors. Each event is stored as a single entry in the \cppinline{TTree}.}
	\end{figure}
	
\section{Communications}
\label{app1:sec:Comm}

	To ensure data readout and dialog in between the machine and the TDCs or in between the webDCS and the DAQ, different communication solutions were used. First of all, it is important to have a module to allow the comminication in between the TDCs and the computer from which the DAQ operates. When this communication is effective, shifters using the webDCS to control data taking can thus send instructions to the DAQ.\\

    \subsection{V1718 USB Bridge}
    \label{app1:ssec:V1718}
    
    In the previous section, the data transfer as been discussed. The importance of the \cppinline{v1718} object (Source Code~\ref{cpp:v1718}), used as private member of \cppinline{DataReader}, was not explicited. VME  master modules are used for communication purposes as they host the USB port that connects the powered crate buffer to the computer were the DAQ is installed. From the source code point of view, this object is used to control the communication status, by reading the returned error codes with \cppinline{v1718::CheckStatus()}, or to check for IRQs coming from the TDCs through \cppinline{v1718::CheckIRQ()}. Finally, to ensure that triggers are blocked at the hardware level, a NIM pulse is sent out of one of the 5 programmable outputs (\cppinline{v1718::SendBUSY()}) to the VETO of the coïndidence module where the trigger signals originate from. As long as this signal is ON, no trigger can reach the TDCs anymore.\\
	
	\begin{code}
	\captionof{listing}{Description of C++ object \cppinline{v1718}.}
	\label{cpp:v1718}
	
    \begin{cppcode}
class v1718{
    private:
        int               Handle;
        Data32            Data;           // Data
        CVIRQLevels       Level;          // Interrupt level
        CVAddressModifier AM;             // Addressing Mode
        CVDataWidth       DataSize;       // Data Format
        Data32            BaseAddress;    // Base Address

    public:
        v1718(IniFile *inifile);
        ~v1718();
        long              GetHandle(void) const;
        int               SetData(Data16 data);
        Data16            GetData(void);
        int               SetLevel(CVIRQLevels level);
        CVIRQLevels       GetLevel(void);
        int               SetAM(CVAddressModifier am);
        CVAddressModifier GetAM(void);
        int               SetDatasize(CVDataWidth datasize);
        CVDataWidth       GetDataSize(void);
        int               SetBaseAddress(Data16 baseaddress);
        Data16            GetBaseAddress(void);
        void              CheckStatus(CVErrorCodes status) const;
        bool              CheckIRQ();
        void              SetPulsers();
        void              SendBUSY(BusyLevel level);
};
    \end{cppcode}
    \end{code}

    \subsection{Configuration file}
    \label{app1:ssec:inifile}
    
    The DAQ software takes as input a configuration file written using INI standard~\cite{INI}. This file is partly filled with the information provided by the shifters when starting data acquisition using the webDCS, as shown by Figure~\ref{fig:scaninfo}. This information is written in section \iniinline{[General]} and will later be stored in the ROOT file that contains the DAQ data as can be seen from Figure~\ref{fig:ROOTfile}. Indeed, another \cppinline{TTree} called \cppinline{RunParameters} as well as the 2 histograms \cppinline{ID}, containing the scan number, start and stop time stamps, and \cppinline{Triggers}, containing the number of triggers requested by the shifter, are available in the data files.
    
    \begin{figure}[H]
		\centering
		\includegraphics[width = \plotwidth]{fig/app1/webDCS-scan-information.png}
		\caption{\label{fig:scaninfo} WebDCS DAQ scan page. On this page, shifters need to choose the type of scan (Rate, Efficiency or Noise Reference scan), the gamma source configuration at the moment of data taking, the beam configuration, and the trigger mode. These information will be stored in the DAQ ROOT output. Are also given the minimal measurement time and waiting time after ramping up of the detectors is over before starting the data acquisition. Then, the list of HV points to scan and the number of triggers for each run of the scan are given in the table underneath.}
	\end{figure}
	
	The rest of the information is written beforehand in the configuration file template, as explicited in Source Code~\ref{ini:INIFile}, and contains the hardware addresses to the differents VME modules in the setup as well as settings for the TDCs. As the TDC settings available in the configuration file are not supposed to be modified, an improvement would be to remove them from the configuration file and to hardcode them inside of the DAQ code itself or to place them into a different INI file that would host only the TDC settings to lower the probability for a bad manipulation of the configuration file that can be modified from one of webDCS' menus.\\
    
    \begin{code}
	\captionof{listing}{INI configuration file template for 4 TDCs. In section \iniinline{[General]}, the number of TDCs is explicited and information about the ongoing run is given. Then, there are sections for each and every VME modules. There buffer addresses are given and for the TDCs, the list of channels to enable is given. Finally, in section \iniinline{[TDCSettings]}, a part of the TDC settings are given.}
	\label{ini:INIFile}
    \begin{inicode}
[General]
Tdcs=4
ScanID=$scanid
HV=$HV
RunType=$runtype
MaxTriggers=$maxtriggers
Beam=$beam
[VMEInterface]
Type=V1718
BaseAddress=0xFF0000
Name=VmeInterface
[TDC0]
Type=V1190A
BaseAddress=0x00000000
Name=Tdc0
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDC1]
Type=V1190A
BaseAddress=0x11110000
Name=Tdc1
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDC2]
Type=V1190A
BaseAddress=0x22220000
Name=Tdc2
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDC3]
Type=V1190A
BaseAddress=0x44440000
Name=Tdc3
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDCSettings]
TriggerExtraSearchMargin=0
TriggerRejectMargin=0
TriggerTimeSubstraction=0b1
TdcDetectionMode=0b01
TdcResolution=0b10
TdcDeadTime=0b00
TdcHeadTrailer=0b1
TdcEventSize=0b1001
TdcTestMode=0b0
BLTMode=1
	\end{inicode}
	\end{code}
    
    \subsection{WebDCS/DAQ intercommunication}
    \label{app1:ssec:dcsdaqcomm}
    
    When shifters send instructions to the DAQ via the configuration file, it is the webDCS itself that gives the start command to the DAQ and then the 2 softwares use inter-process communication through file to synchronise themselves. This communication file is represented by the variable \cppinline{const string __runstatuspath}.\\
    On one side, the webDCS sends commands or status that are readout by the DAQ:
    \begin{itemize}
    	\item[•] \verb+INIT+, status sent when launching a scan and read via function \cppinline{CtrlRunStatus(...)},
    	\item[•] \verb+START+, command to start data taking and read via function \cppinline{CheckSTART()},
    	\item[•] \verb+STOP+, command to stop data taking at the end of the scan and read via function \cppinline{CheckSTOP()}, and
    	\item[•] \verb+KILL+, command to kill data taking sent by user and read via function \cppinline{CheckKILL()}
    \end{itemize}
and on the other, the DAQ sends status that are controled by the webDCS:
    \begin{itemize}
    	\item[•] \verb+DAQ_RDY+, sent with \cppinline{SendDAQReady()} to signify that the DAQ is ready to receive commands from the webDCS,
    	\item[•] \verb+RUNNING+, sent with \cppinline{SendDAQRunning()} to signify that the DAQ is taking data,
    	\item[•] \verb+DAQ_ERR+, sent with \cppinline{SendDAQError()} to signify that the DAQ didn't receive the expected command from the webDCS or that the launch command didn't have the right number of arguments,
    	\item[•] \verb+RD_ERR+, sent when the DAQ wasn't able to read the communication file, and
    	\item[•] \verb+WR_ERR+, sent when the DAQ wasn't able to write into the communication file.
    \end{itemize}
    
    \subsection{Example of inter-process communication cycle}
    \label{app1:ssec:commex}
    
    Under normal conditions, the webDCS and the DAQ processes exchange commands and status via the file hosted at the address \cppinline{__runstatuspath}, as explained in subsection~\ref{app1:ssec:dcsdaqcomm}. An example of cycle is given in Table~\ref{tab:intercom}. In this example, the steps 3 to 5 are repeated as long as the webDCS tells the DAQ to take data. A data taking cycle is the equivalent as what is called a \textit{Scan} in GIF++ jargon, referring to a set a runs with several HV steps. Each repetition of steps 3 to 5 is then equivalent to a single \textit{Run}.\\
    
    At any moment during the data taking, for any reason, the shifter can decide that the data taking needs to be stopped before it reached the end of the scheduled cycle. Thus at any moment on the cycle, the content of the inter-process communication file will be changed to \verb+KILL+ and the DAQ will shut down right away. The DAQ checks for \verb+KILL+ signals every 5s after the TDCs configuration is over. So far, the function \cppinline{CheckKILL()} has been used only inside of the data taking loop of method \cppinline{DataReader::Run()} and thus, if the shifter decides to KILL the data taking during the TDC configuration phase or the HV ramping in between 2 HV steps, the DAQ will not e stopped smoothly and a \textit{force kill} command will be sent to stop the DAQ process that is still awake on the computer. Improvements can be brought on this part of the software to make sure that the DAQ can safely shutdown at any moment.\\
    
    \begin{table}
	    \begin{tabular}{|c|c|c|c|}
	    	\hline
	    	step & actions of webDCS & status of DAQ & \cppinline{__runstatuspath}\\
	    	\hline
	    	1 & launch DAQ & readout of IniFfile & \verb+INIT+\\
	    	 & ramp voltages & configuration of TDCs & \\
	    	 & ramping over & & \\
	    	 & wait for currents stabilization & & \\
	    	\hline
	    	2 &  & configuration done & \verb+DAQ_RDY+\\
	    	 &  & send DAQ ready & \\
	    	 &  & wait for \verb+START+ signal & \\
	    	\hline
	    	3 & waiting time over & & \verb+START+\\
	    	 & send \verb+START+ & & \\
	    	\hline
	    	4 & wait for run to end & data taking ongoing & \verb+RUNNING+\\
	    	 & monitor DAQ run status & check for \verb+KILL+ signal & \\
	    	\hline
	    	5 &  & run over & \verb+DAQ_RDY+\\
	    	 &  & send \verb+DAQ_RDY+ & \\
	    	 &  & wait for next DCS signal & \\
	    	\hline
	    	6 & ramp voltages &  & \verb+DAQ_RDY+\\
	    	 & ramping over &  & \\
	    	 & wait for currents stabilization &  & \\
	    	\hline
	    	3 & waiting time over & & \verb+START+\\
	    	 & send \verb+START+ & & \\
	    	\hline
	    	4 & wait for run to end & update IniFile information & \verb+RUNNING+\\
	    	 & monitor DAQ run status & data taking ongoing & \\
	    	 &  & check for \verb+KILL+ signal & \\
	    	\hline
	    	5 &  & run over & \verb+DAQ_RDY+\\
	    	 &  & send \verb+DAQ_RDY+ & \\
	    	 &  & wait for next DCS signal & \\
	    	\hline
	    	7 & send command \verb+STOP+ & DAQ shuts down & \verb+STOP+\\
	    	\hline
	    \end{tabular}
	    \caption{\label{tab:intercom} Inter-process communication cycles in between the webDCS and the DAQ through file string signals.}
    \end{table}
    
\section{DAQ algorithm overview}
\label{app1:sec:algo}

\section{Software export}
\label{app1:sec:export}


\clearpage{\pagestyle{empty}\cleardoublepage}
