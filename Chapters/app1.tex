% Header
\renewcommand\evenpagerightmark{{\scshape\small Appendix A}}
\renewcommand\oddpageleftmark{{\scshape\small A data acquisition software for VME CAEN TDCs}}

\renewcommand{\bibname}{References}

\hyphenation{}

\chapter[A data acquisition software for CAEN VME TDCs]%
{A data acquisition software for CAEN VME TDCs}
\label{app1}

Certifying detectors in the perspective of HL-LHC required to develop tools for the GIF++ experiment. Among them was the C++ \acf{DAQ} software that allows to make the communications in between a computer and TDC modules in order to retrieve the RPC data~\cite{GIFDAQ}. In this appendix, details about this software, as of how the software was written, how it functions and how it can be exported to another similar setup, will be given.

\section{GIF++ DAQ file tree}
\label{app1:sec:code}

	GIF++ DAQ source code is fully available on github at \url{https://github.com/afagot/GIF_DAQ}. The software requires 3 non-optional dependencies:

	\begin{itemize}
		\item[•] \href{http://www.caen.it/csite/CaenProd.jsp?idmod=417&parent=11}{CAEN USB Driver}, to mount the VME hardware,
		\item[•] \href{http://www.caen.it/csite/CaenProd.jsp?idmod=689&parent=38}{CAEN VME Library}, to communicate with the VME hardware, and
		\item[•] \href{https://root.cern.ch/downloading-root}{ROOT}, to organize the collected data into a TTree.
	\end{itemize}

	The CAEN VME library will not be packaged by distributions and will need to be installed manually. To compile the GIF++ DAQ project via a terminal, from the DAQ folder use the command:\\

	\begin{bashcode}
 make
	\end{bashcode}
\vspace{5mm}
	The source code tree is provided below along with comments to give an overview of the files' content. The different objects created for this project (\cppinline{v1718}, \cppinline{v1190a}, \cppinline{IniFile} \& \cppinline{DataReader}) will be described in details in the following sections.\\
	
	\newpage

	\dirtree{%
	 .1 GIF\_DAQ.
	 .2 bin.
	 .3 daq\DTcomment{executable}.
	 .2 include\DTcomment{list of C++ header files}.
	 .3 CAENVMElib.h\DTcomment{CAEN C++ libs}.
	 .3 CAENVMEoslib.h\DTcomment{CAEN OS C++ libs}.
	 .3 CAENVMEtypes.h\DTcomment{CAEN variables}.
	 .3 DataReader.h\DTcomment{declaration of object DataReader}.
	 .3 IniFile.h\DTcomment{declaration of object IniFile for ini parser}.
	 .3 MsgSvc.h\DTcomment{declaration of DAQ log messages}.
	 .3 utils.h\DTcomment{declaration of useful variables and comm. functions}.
	 .3 v1190a.h\DTcomment{declaration of object v1190a}.
	 .3 v1718.h\DTcomment{declaration of object v1718}.
	 .2 lib\DTcomment{CAEN library}.
	 .3 install.
	 .3 x86.
	 .4 libCAENVME.so.2.41.
	 .2 obj\DTcomment{binary files created by compiler}.
	 .3 ....
	 .2 src\DTcomment{list of C++ source files}.
	 .3 daq.cxx\DTcomment{main file}.
	 .3 DataReader.cxx\DTcomment{definition of DataReader's methods}.
	 .3 IniFile.cxx\DTcomment{definition of IniFile's methods}.
	 .3 MsgSvc.cxx\DTcomment{definition of log messaging functions}.
	 .3 utils.cxx\DTcomment{definition of useful communication functions}.
	 .3 v1190a.cxx\DTcomment{declaration of v1190a's methods}.
	 .3 v1718.cxx\DTcomment{declaration of v1718's methods}.
	 .2 makefile\DTcomment{compiler instructions}.
	 .2 README.md\DTcomment{REAMDE file for github}.
	}
	
\section{Usage of the DAQ}
\label{app1:sec:usage}

	GIF++ DAQ, as used in GIF++, is not a standalone software. Indeed, the system being more complexe, the DAQ only is a sub-layer of the software architecture developped to control and monitor the RPCs that are placed into the bunker for performance study in an irradiated environment. The top layer of GIF++ is a \acf{webDCS} application. The DAQ is only called by the webDCS when data needs to be acquired. The webDCS operates the DAQ through command line. To start the DAQ, the webDCS calls:\\
	
	\begin{bashcode}
 bin/daq /path/to/the/log/file/in/the/output/data/folder
	\end{bashcode}
\vspace{5mm}
	where \textinline{/path/to/the/log/file/in/the/output/data/folder} is the only argument required. This log file is important for the webDCS as this file contains all the content of the communication of the webDCS and the different systems monitored by the webDCS. Its content is constantly displayed during data taking for the users to be able to follow the operations. The communication messages are normally sent to the webDCS log file via the functions declared in file \textinline{MsgSvc.h}, typically \cppinline{MSG_INFO(string message)}.\\

\section{Description of the readout setup}
\label{app1:sec:setup}

    The CMS RPC setup at GIF++ counts 5 V1190A \acf{TDC} manufactured by CAEN~\cite{V1190AMUT}. V1190A are VME units accepting 128 independent Multi-Hit/Multi-Event TDC channels whose signals are treated by 4 \SI{100}{ps} high performance TDC chips developped by CERN / ECP-MIC Division. The communication between the computer and the TDCs to transfer data is done via a V1718 VME master module also manufactured by CAEN and operated from a USB port~\cite{V1718MUT}. These VME modules are all hosted into a 6U VME 6021 powered crate manufactured by W-Ie-Ne-R than can accomodate up to 21 VME bus cards~\cite{6U6000MUT}. These 3 components of the DAQ setup are shown in Figure~\ref{fig:DAQSetup}.\\
    
    \begin{figure}[H]
    \hspace{-15mm}
        \begin{subfigure}{0.1\linewidth}
		    \centering
			\includegraphics[height = 10cm]{fig/app1/V1190A-front.pdf}
			\caption{\label{fig:DAQSetup:A}}
		\end{subfigure}
		\begin{subfigure}{0.25\linewidth}
		    \centering
			\includegraphics[height = 10cm]{fig/app1/V1718-front.pdf}
			\caption{\label{fig:DAQSetup:B}}
		\end{subfigure}
		\begin{subfigure}{0.65\linewidth}
		    \centering
			\includegraphics[width = \plotwidth]{fig/app1/Wiener-front.png}
			\caption{\label{fig:DAQSetup:C}}
		\end{subfigure}
		\caption{\label{fig:DAQSetup} (\ref{fig:DAQSetup:A}) View of the front panel of a V1190A TDC module~\cite{V1190AMUT}. (\ref{fig:DAQSetup:B}) View of the front panel of a V1718 Bridge module~\cite{V1718MUT}. (\ref{fig:DAQSetup:C}) View of the front panel of a 6U 6021 VME crate~\cite{6U6000MUT}.}
	\end{figure}

\section{Data read-out}
\label{app1:sec:Data}

	To efficiently perform a data readout algorithm, C++ objects to handle the VME modules (TDCs and VME bridge) have been created along with objects to store data and read the configuration file that comes as an input of the DAQ software.\\

    \subsection{V1190A TDCs}
    \label{app1:ssec:V1190A}

	The DAQ used at GIF takes profit of the \textit{Trigger Matching Mode} offered by V1190A modules. This setting is enabled through the method \cppinline{v1190a::SetTrigMatching (int ntdcs)} where \cppinline{ntdcs} is the total number of TDCs in the setup this setting needs to be enabled for (Source Code~\ref{cpp:v1190a}). A trigger matching is performed in between a trigger time tag, a trigger signal sent into the TRIGGER input of the TDC visible on Figure~\ref{fig:DAQSetup:A}, and the channel time measurements, signals recorded from the detectors under test in our case. Control over this data acquisition mode, explained through Figure~\ref{fig:V1190A-TMM}, is offered via 4 programmable parameters:
        
	\begin{itemize}
		\item \textbf{match window:} the matching between a trigger and a hit is done within a programmable time window. This is set via the method\\ \cppinline{void v1190a::SetTrigWindowWidth(Uint windowWidth,int ntdcs)}
		\item \textbf{window offset:} temporal distance between the trigger tag and the start of the trigger matching window. This is set via the method\\ \cppinline{void v1190a::SetTrigWindowWidth(Uint windowWidth,int ntdcs)}
		\item \textbf{extra search margin:} an extended time window is used to ensure that all matching hits are found. This is set via the method\\ \cppinline{void v1190a::SetTrigSearchMargin(Uint searchMargin,int ntdcs)}
		\item \textbf{reject margin:} older hits are automatically rejected to preven buffer overflows and to speed up the search time. This is set via the method\\ \cppinline{void v1190a::SetTrigRejectionMargin(Uint rejectMargin,int ntdcs)}
	\end{itemize}
    
    \begin{figure}[H]
		\centering
		\includegraphics[width = 1.25\plotwidth]{fig/app1/V1190A-TMM.pdf}\\
		\caption{\label{fig:V1190A-TMM} Module V1190A \textit{Trigger Matching Mode} timing diagram~\cite{V1190AMUT}.}
	\end{figure}
	
	Each of these 4 parameters are given in number of clocks, \SI{1}{clock} being \SI{25}{ns} long. It is easy to understand at this level that there are 3 possible functionning settings:
        
	\begin{itemize}
		\item \textbf{1:} the match window is entirely contained after the trigger signal,
		\item \textbf{2:} the match window overlaps the trigger signal, or
		\item \textbf{3:} the match window is entirely contained before the trigger signal as displayed on Figure~\ref{fig:V1190A-TMM}.
	\end{itemize}
	
	In both the first and second cases, the sum of the window width and of the offset can be set to a maximum of \SI{40}{clocks}, which corresponds to \SI{1}{\micro s}. Evidently, the offset can be negative, allowing for a longer match window, with the constraint of having the window ending at most \SI{1}{\micro s} after the trigger signal. In the third case, the maximum negative offset allowed is of \SI{2048}{clocks} (12 bit) corresponding to \SI{51.2}{\micro s}, the match window being strictly smaller than the offset. In the case of GIF++, the choice has been made to use this last setting by delaying the trigger signal. During the studies performed in GIF++, both the efficiency of the RPCs, probed using a muon beam, and the noise or gamma background rate are monitored. The extra search and reject margins are left unused.\\
	To probe the efficiency of RPC detectors, the trigger time tag is provided by the coïncidence of scintillators when a bunch of muons passes through GIF++ area is used to trigger the data acquisition. For this measurement, it is useful to reduce the match window width only to contain the muon information. Indeed, the delay in between a trigger signal and the detection of the corresponding muon in the RPC being very contant (typically a few tens of ns due to jitter and cable length), the muon signals are very localised in time. Thus, due to a delay of approximalety \SI{325}{ns} in between the muons and the trigger, the settings where chosen to have a window width of \SI{24}{clocks} (\SI{600}{ns}) centered on the muon peak thanks to a negative offset of \SI{29}{clocks} (\SI{725}{ns}).\\
	On the otherhand, monitoring the rates don't require for the DAQ to look at a specific time window. It is important to integrate enough time to have a robust measurement of the rate as the number of hits per time unit. The triggerring signal is provided by a pulse generator at a frequency of \SI{300}{Hz} to ensure that the data taking occurs in a random way, with respect to beam physics, to probe only the irradiation spectrum on the detectors. The match window is set to \SI{400}{clocks} (\SI{10}{\micro s}) and the negative offset to \SI{401}{clocks} as it needs to exceed the value of the match window.\\
	
	\begin{code}
    \begin{cppcode}
class v1190a
{
 private :
    long              Handle;
    vector<Data32>    Address;
    CVDataWidth       DataWidth;
    CVAddressModifier AddressModifier;

 public:

    v1190a(long handle, IniFile *inifile, int ntdcs);
    ~v1190a();
    Data16 write_op_reg(Data32 address, int code, string error);
    Data16 read_op_reg(Data32 address, string error);
    void   Reset(int ntdcs);
    void   Clear(int ntdcs);
    void   TestWR(Data16 value,int ntdcs);
    void   CheckTDCStatus(int ntdcs);
    void   CheckCommunication(int ntdcs);
    void   SetTDCTestMode(Data16 mode,int ntdcs);
    void   SetTrigMatching(int ntdcs);
    void   SetTrigTimeSubstraction(Data16 mode,int ntdcs);
    void   SetTrigWindowWidth(Uint windowWidth,int ntdcs);
    void   SetTrigWindowOffset(Uint windowOffset,int ntdcs);
    void   SetTrigSearchMargin(Uint searchMargin,int ntdcs);
    void   SetTrigRejectionMargin(Uint rejectMargin,int ntdcs);
    void   GetTrigConfiguration(int ntdcs);
    void   SetTrigConfiguration(IniFile *inifile,int ntdcs);
    void   SetTDCDetectionMode(Data16 mode,int ntdcs);
    void   SetTDCResolution(Data16 lsb,int ntdcs);
    void   SetTDCDeadTime(Data16 time,int ntdcs);
    void   SetTDCHeadTrailer(Data16 mode,int ntdcs);
    void   SetTDCEventSize(Data16 size,int ntdcs);
    void   SwitchChannels(IniFile *inifile,int ntdcs);
    void   SetIRQ(Data32 level, Data32 count,int ntdcs);
    void   SetBlockTransferMode(Data16 mode,int ntdcs);
    void   Set(IniFile *inifile,int ntdcs);
    void   CheckStatus(CVErrorCodes status) const;
    int    ReadBlockD32(Uint tdc, const Data16 address,
               Data32 *data, const Uint words, bool ignore_berr);
    Uint   Read(RAWData *DataList,int ntdcs);
};
    \end{cppcode}
	\captionof{listing}{Description of C++ object \cppinline{v1190a}.}
	\label{cpp:v1190a}
	\vspace{5mm}
    \end{code}
	
	The v1190a object, defined in the DAQ software as in Source Code~\ref{cpp:v1190a}, offers the possility to concatenate all TDCs in the readout setup into a single object containing a list of hardware addresses (addresses to access the TDCs' buffer through the VME crate) and each constructor and method acts on the list of TDCs.\\
	
	\subsection{DataReader}
	\label{app1:ssec:DataReader}
	
	Enabled thanks to \cppinline{v1190a::SetBlockTransferMode(Data16 mode, int ntdcs)}, the data transfer is done via \acf{BLT}. Using BLT allows to tranfer a fixed number of events called a \textit{block}. This is used together with an \acf{AFL} of the TDCs' output buffers, defined through \cppinline{v1190a::SetIRQ(Data32 level, Data32 count,int ntdcs)}. This AFL gives the maximum amount of 32735 words (16 bits, corresponding to the depth of a TDC output buffer) that can writen in a buffer before an \acf{IRQ} is generated and seen by the VME Bridge, stopping the data acquisition to transfer the content of each TDC buffers before resuming. For each trigger, 6 words or more are written into the TDC buffer:
	
	\begin{itemize}
		\item \textbf{a global header} providing information of the event number since the beginning of the data acquisition,
		\item \textbf{a TDC header},
		\item \textbf{the TDC data} (\textit{if any}), 1 for each hit recorded during the event, providing the channel and the time stamp associated to the hit,
		\item \textbf{a TDC error} providing error flags,
		\item \textbf{a TDC trailer},
		\item \textbf{a global trigger time tag} that provides the absolute trigger time relatively to the last reset, and
		\item \textbf{a global trailer} providing the total word count in the event.
	\end{itemize}
	
	As previously described in Section~\ref{ssec:PulseProc}, CMS RPC FEEs provide us with \SI{100}{ns} long LVDS output signals that are injected into the TDCs' input. Any avalanche signal that gives a signal above the FEEs threshold is thus recorded by the TDCs as a hit within the match window. Each hit is assigned to a specific TDC channel with a time stamp, with a precision of \SI{100}{ps}. The reference time, $t_0=0$, is provided by the beginning of the match window. Thus for each trigger, coming from a scintillator coïncidence or the pulse generator, a list of hits is stored into the TDCs' buffers and will then be transfered into a ROOT Tree.\\
	
	When the BLT is used, it is easy to understand that the maximum number of words that have been set as ALF will not be a finite number of events or, at least, the number of events that would be recorded into the TDC buffers will not be a multiple of the block size. In the last BLT cycle to tranfer data, the number of events to transfer will most propably be lower than the block size. In that case, the TDC can add fillers at the end of the block but this option requires to send more data to the computer and is thus a little slower. Another solution is to finish the transfer after the last event by sending a bus error that states that the BLT reached the last event in the pile. This method has been chosen in GIF++.\\
	
	Due to irradiation, an event in GIF++ can count up to 300 words per TDC. A limit of 4096 words (12 bits) has been set to generate IRQ which represent from 14 to almost 700 events depending on the average of hits collected per event. Then the block size has been set to 100 events with enabled bus errors. When an AFL is reached for one of the TDCs, the VME bridge stops the acquisition by sending a BUSY signal.\\
	
	The data is then transfered one TDC at a time into a structure called \cppinline{RAWData} (Source Code~\ref{cpp:rawdata}).\\
	
	\begin{code}
    \begin{cppcode}
struct RAWData{
    vector<int>            *EventList;
    vector<int>            *NHitsList;
    vector<int>            *QFlagList;
    vector<vector<int> >   *ChannelList;
    vector<vector<float> > *TimeStampList;
};
    \end{cppcode}
	\captionof{listing}{Description of data holding C++ structure \cppinline{RAWData}.}
	\label{cpp:rawdata}
	\vspace{5mm}
    \end{code}

	In order to organize the data transfer and the data storage, an object called \cppinline{DataReader} was created (Source Code~\ref{cpp:datareader}). On one hand, it has \cppinline{v1718} and \cppinline{v1190a} objects as private members for communication purposes, such as VME modules settings via the configuration file \cppinline{*iniFile} or data read-out through \cppinline{v1190a::Read()} and on the other hand, it contains the struture \cppinline{RAWData} that allows to organise the data in vectors reproducing the tree structre of a ROOT file.\\
	
	\begin{code}
    \begin{cppcode}
class DataReader
{
    private:
        bool     StopFlag;
        IniFile *iniFile;
        Data32   MaxTriggers;
        v1718   *VME;
        int      nTDCs;
        v1190a  *TDCs;
        RAWData  TDCData;

    public:
        DataReader();
        virtual ~DataReader();
        void     SetIniFile(string inifilename);
        void     SetMaxTriggers();
        Data32   GetMaxTriggers();
        void     SetVME();
        void     SetTDC();
        int      GetQFlag(Uint it);
        void     Init(string inifilename);
        void     FlushBuffer();
        void     Update();
        string   GetFileName();
        void     WriteRunRegistry(string filename);
        void     Run();
};
    \end{cppcode}
	\captionof{listing}{Description of C++ object \cppinline{DataReader}.}
	\label{cpp:datareader}
	\vspace{5mm}
    \end{code}

    Each event is tranferred from \cppinline{TDCData} and saved into branches of a ROOT \cppinline{TTree} as 3 integers that represent the event ID (\cppinline{EventCount}), the number of hits read from the TDCs (\cppinline{nHits}), and the quality flag that provides information for any problem in the data transfer (\cppinline{qflag}), and 2 lists of \textit{nHits} elements containing the fired TDC channels (\cppinline{TDCCh}) and their respective time stamps (\cppinline{TDCTS}), as presented in Source Code~\ref{cpp:datatranfer}. The ROOT file file is named using information contained into the configuration file, presented in section~\ref{app1:ssec:inifile}. The needed information is extracted using method \cppinline{DataReader::GetFileName()} and allow to build the output filename format \textinline{ScanXXXXXX_HVX_DAQ.root} where \textinline{ScanXXXXXX} is a 6 digit number representing the scan number into GIF++ database and \textinline{HVX} the HV step within the scan that can be more than a single digit. An example of ROOT data file is provided with Figure~\ref{fig:ROOTfile}.\\
    
    \begin{code}
    \begin{cppcode}
RAWData TDCData;
TFile *outputFile = new TFile(outputFileName.c_str(),"recreate");
TTree *RAWDataTree = new TTree("RAWData","RAWData");

int           EventCount = -9;
int           nHits = -8;
int           qflag = -7;
vector<int>   TDCCh;
vector<float> TDCTS;

RAWDataTree->Branch("EventNumber",&EventCount, "EventNumber/I");
RAWDataTree->Branch("number_of_hits",&nHits,"number_of_hits/I");
RAWDataTree->Branch("Quality_flag",&qflag,"Quality_flag/I");
RAWDataTree->Branch("TDC_channel",&TDCCh);
RAWDataTree->Branch("TDC_TimeStamp",&TDCTS);

//...
//Here read the TDC data using v1190a::Read() and place it into
//TDCData for as long as you didn't collect the requested amount
//of data.
//...
    
for(Uint i=0; i<TDCData.EventList->size(); i++){
    EventCount  = TDCData.EventList->at(i);
    nHits       = TDCData.NHitsList->at(i);
    qflag       = TDCData.QFlagList->at(i);
    TDCCh       = TDCData.ChannelList->at(i);
    TDCTS       = TDCData.TimeStampList->at(i);
    RAWDataTree->Fill();
}
    \end{cppcode}
    \captionof{listing}{Highlight of the data transfer and organisation within \cppinline{DataReader::Run()} after the data has been collected into \cppinline{TDCData}.}
	\label{cpp:datatranfer}
    \vspace{5mm}
    \end{code}

    \begin{figure}[H]
		\centering
		\includegraphics[width = \plotwidth]{fig/app1/webDCS-ROOT-browser.png}
		\caption{\label{fig:ROOTfile} Structure of the ROOT output file generated by the DAQ. The 5 branches (\cppinline{EventNumber}, \cppinline{number_of_hits}, \cppinline{Quality_flag}, \cppinline{TDC_channel} and \cppinline{TDC_TimeStamp}) are visible on the left panel of the ROOT browser. On the right panel is visible the histogram corresponding to the variable \cppinline{nHits}. In this specific example, there were approximately 50k events recorded to measure the gamma irradiation rate on the detectors. Each event is stored as a single entry in the \cppinline{TTree}.}
	\end{figure}
	
	\subsection{Data quality flag}
	\label{app1:ssec:QFlag}
	
	Among the parameters that are recorded for each event, the quality flag, defined in Source Code~\ref{cpp:qflag}, is determined on the fly by checking the data recorded by every single TDC. From method \cppinline{v1190a::Read()}, it can be understood that the content of each TDC buffer is readout one TDC at a time. Entries are created in the data list for the first TDC and then, when the second buffer is readout, events corresponding to entries that have already been created to store data for the previous TDC are added to the existing list element. On the contrary, when an event entry has not been yet created in the data list, a new entry is created.\\
	
	\begin{code}
    \begin{cppcode}
typedef enum _QualityFlag {
    GOOD      = 1,
    CORRUPTED = 0
} QualityFlag;
    \end{cppcode}
    \captionof{listing}{Definition of the quality flag \cppinline{enum}.} 
	\label{cpp:qflag}
    \vspace{5mm}
    \end{code}
	
	It is possible that each TDC buffer contains a different number of events. In cases where the first element in the buffer list is an event for corresponds to a new entry, the difference in between the intry from the buffer and the last entry in the data list is recorded and checked. If it is greater than 1, what should never be the case, the quality flag is set to \cppinline{CORRUPTED} for this TDC and an empty entry is created in the place of the missing ones. Missing entries are believe to be the result of a bad hold on the TDC buffers at the moment of the readout. Indeed, the software hold is effective only on 1 TDC at a time and no solution as been found yet to completely block the writting in the buffers when an IRQ is received.
	
	At the end of each BLT cycle, the ID of the last entry stored for each TDC buffer is not recorded. When starting the next cycle, if the first entry in the pile corresponds to an event already existing in the list, the readout will start from this list element and will not be able to check the difference in between this entry's ID and the one of the last entry that was recorded for this TDC buffer in the previous cycle. In the case events were missing, the flag stays at its initial value of 0, which is similar to \cppinline{CORRUPTED} and it is assumed that then this TDC will not contribute to \cppinline{number_of_hits}, \cppinline{TDC_channel} or \cppinline{TDC_TimeStamp}.
	
	Finally, since there will be 1 \cppinline{RAWData} entry per TDC for each event (meaning \cppinline{nTDCs} entries, referring to \cppinline{DataReader} private attribute), the individual flags of each TDC will be added together. The final format is an integer composed \cppinline{nTDCs} digits where each digit is the flag of a specific TDC. This is constructed using powers of 10 like follows:
	
	\begin{itemize}
		\item[] TDC 0: \cppinline{QFlag} $= 10^0 \times$ \cppinline{_QualityFlag}
		\item[] TDC 1: \cppinline{QFlag} $= 10^1 \times$ \cppinline{_QualityFlag}
		\item[] ...
		\item[] TDC N: \cppinline{QFlag} $= 10^N \times$ \cppinline{_QualityFlag}
	\end{itemize}
                         
and the final flag to be with N digits:
	
	\begin{itemize}
		\item[] \cppinline{QFlag} = \textinline{n....3210}
	\end{itemize}
	
each digit being 1 or 0. Bellow is given an example with a 4 TDCs setup.
	
	\begin{itemize}
		\item[] If all TDCs were good : \cppinline{QFlag} = \textinline{1111},
		\item[] but if TDC 2 was corrupted : \cppinline{QFlag} = \textinline{1011}.
	\end{itemize}
                        
	When data taking is over and the data contained in the dynamical \cppinline{RAWData} structure is transfered to the ROOT file, all the 0s are changed into 2s by calling the method \cppinline{DataReader::GetQFlag()}. This will help translating the flag without knowing the number of TDCs beforehand. Indeed, a flag \textinline{111} could be due to a 3 TDC setup with 3 good individual TDC flags or to a more than 3 TDC setup with TDCs those ID is greater than 2 being \cppinline{CORRUPTED}, thus giving a 0.
	
	The quality flag has been introduced quite late, in October 2017 only, to the list of GIF++ DAQ parameters to be recorded into the output ROOT file. Before this addition, the missing data, corrupting the quality for the offline analysis, was contributing to artificially fill data with lower multiplicity. Looking at \cppinline{TBranch number_of_hits} provides an information about the data of the full GIF++ setup. When a TDC is not able to transfer data for a specific event, the effect is a reduction of the total number of hits recorded in the full setup, this is what can be seen from Figure~\ref{fig:qflag-daq}. After offline reconstruction detector by detector, the effect of missing events can be seen in the artificially filled bin at multiplicity 0 shown in Figure~\ref{fig:qflag-kodel}. Nontheless, for data wih high irradiation levels, as it is he case for Figure~\ref{fig:qflag-kodel:A}, discarding the fake multiplicity 0 data can be done easily during the offline analysis. At lower radiation, the missing events contribution becomes more problematic as the multiplicity distribution overlaps the multiplicity 0 and that in the same time the proportion of missing events decreases. Attempts to fit the distribution with a Poisson or skew distribution function were not conclusive and this very problem has been at the origin of the quality flag that allows to give a non ambiguous information about each event quality.\\
	
	\begin{figure}[H]
        \begin{subfigure}{0.5\linewidth}
		    \centering
			\includegraphics[width = \linewidth]{fig/app1/No_Qflag_nhits_DAQ.pdf}
			\caption{\label{fig:qflag-daq:A}}
		\end{subfigure}
		\begin{subfigure}{0.5\linewidth}
		    \centering
			\includegraphics[width = \linewidth]{fig/app1/With_Qflag_nhits_DAQ.pdf}
			\caption{\label{fig:qflag-daq:B}}
		\end{subfigure}
		\caption{\label{fig:qflag-daq} The effect of the quality flag is explained by presenting the content of \cppinline{TBranch number_of_hits} of a data file without \cppinline{Quality_flag} in Figure~\ref{fig:qflag-daq:A} and the content of the same \cppinline{TBranch} for data corresponding to a \cppinline{Quality_flag} where all TDCs were labelled as \cppinline{GOOD} in Figure~\ref{fig:qflag-daq:B} taken with similar conditions. It can be noted that the number of entries in Figure~\ref{fig:qflag-daq:B} is slightly lower then in Figure~\ref{fig:qflag-daq:A} due to the excluded events.}
	\end{figure}
	
	\begin{figure}[H]
        \begin{subfigure}{0.5\linewidth}
		    \centering
			\includegraphics[width = \linewidth]{fig/app1/No_Qflag_nhits_KODEL.pdf}
			\caption{\label{fig:qflag-kodel:A}}
		\end{subfigure}
		\begin{subfigure}{0.5\linewidth}
		    \centering
			\includegraphics[width = \linewidth]{fig/app1/With_Qflag_nhits_KODEL.pdf}
			\caption{\label{fig:qflag-kodel:B}}
		\end{subfigure}
		\caption{\label{fig:qflag-kodel} Using the same data as previously showed in Figure~\ref{fig:qflag-daq}, the effect of the quality flag is explained by presenting the reconstructed hit multiplicity of a data file without \cppinline{Quality_flag} in Figure~\ref{fig:qflag-kodel:A} and the reconstructed content of the same RPC partition for data corresponding to a \cppinline{Quality_flag} where all TDCs were labelled as \cppinline{GOOD} in Figure~\ref{fig:qflag-kodel:B} taken with similar conditions. The artificial high content of bin 0 is completely suppressed.}
	\end{figure}
	
\section{Communications}
\label{app1:sec:Comm}

	To ensure data readout and dialog in between the machine and the TDCs or in between the webDCS and the DAQ, different communication solutions were used. First of all, it is important to have a module to allow the comminication in between the TDCs and the computer from which the DAQ operates. When this communication is effective, shifters using the webDCS to control data taking can thus send instructions to the DAQ.\\

    \subsection{V1718 USB Bridge}
    \label{app1:ssec:V1718}
    
    In the previous section, the data transfer as been discussed. The importance of the \cppinline{v1718} object (Source Code~\ref{cpp:v1718}), used as private member of \cppinline{DataReader}, was not explicited. VME  master modules are used for communication purposes as they host the USB port that connects the powered crate buffer to the computer were the DAQ is installed. From the source code point of view, this object is used to control the communication status, by reading the returned error codes with \cppinline{v1718::CheckStatus()}, or to check for IRQs coming from the TDCs through \cppinline{v1718::CheckIRQ()}. Finally, to ensure that triggers are blocked at the hardware level, a NIM pulse is sent out of one of the 5 programmable outputs (\cppinline{v1718::SendBUSY()}) to the VETO of the coïndidence module where the trigger signals originate from. As long as this signal is ON, no trigger can reach the TDCs anymore.\\
	
	\begin{code}
    \begin{cppcode}
class v1718{
    private:
        int               Handle;
        Data32            Data;           // Data
        CVIRQLevels       Level;          // Interrupt level
        CVAddressModifier AM;             // Addressing Mode
        CVDataWidth       DataSize;       // Data Format
        Data32            BaseAddress;    // Base Address

    public:
        v1718(IniFile *inifile);
        ~v1718();
        long              GetHandle(void) const;
        int               SetData(Data16 data);
        Data16            GetData(void);
        int               SetLevel(CVIRQLevels level);
        CVIRQLevels       GetLevel(void);
        int               SetAM(CVAddressModifier am);
        CVAddressModifier GetAM(void);
        int               SetDatasize(CVDataWidth datasize);
        CVDataWidth       GetDataSize(void);
        int               SetBaseAddress(Data16 baseaddress);
        Data16            GetBaseAddress(void);
        void              CheckStatus(CVErrorCodes status) const;
        bool              CheckIRQ();
        void              SetPulsers();
        void              SendBUSY(BusyLevel level);
};
    \end{cppcode}
    \captionof{listing}{Description of C++ object \cppinline{v1718}.}
	\label{cpp:v1718}
	\vspace{5mm}
    \end{code}

    \subsection{Configuration file}
    \label{app1:ssec:inifile}
    
    The DAQ software takes as input a configuration file written using INI standard~\cite{INI}. This file is partly filled with the information provided by the shifters when starting data acquisition using the webDCS, as shown by Figure~\ref{fig:scaninfo}. This information is written in section \iniinline{[General]} and will later be stored in the ROOT file that contains the DAQ data as can be seen from Figure~\ref{fig:ROOTfile}. Indeed, another \cppinline{TTree} called \cppinline{RunParameters} as well as the 2 histograms \cppinline{ID}, containing the scan number, start and stop time stamps, and \cppinline{Triggers}, containing the number of triggers requested by the shifter, are available in the data files. Moreover, \iniinline{ScanID} and \iniinline{HV} are then used to construct the file name thanks to the method \cppinline{DataReader::GetFileName()}.
    
    \begin{figure}[H]
		\centering
		\includegraphics[width = \plotwidth]{fig/app1/webDCS-scan-information.png}
		\caption{\label{fig:scaninfo} WebDCS DAQ scan page. On this page, shifters need to choose the type of scan (Rate, Efficiency or Noise Reference scan), the gamma source configuration at the moment of data taking, the beam configuration, and the trigger mode. These information will be stored in the DAQ ROOT output. Are also given the minimal measurement time and waiting time after ramping up of the detectors is over before starting the data acquisition. Then, the list of HV points to scan and the number of triggers for each run of the scan are given in the table underneath.}
	\end{figure}
	
	The rest of the information is written beforehand in the configuration file template, as explicited in Source Code~\ref{ini:INIFile}, and contains the hardware addresses to the differents VME modules in the setup as well as settings for the TDCs. As the TDC settings available in the configuration file are not supposed to be modified, an improvement would be to remove them from the configuration file and to hardcode them inside of the DAQ code itself or to place them into a different INI file that would host only the TDC settings to lower the probability for a bad manipulation of the configuration file that can be modified from one of webDCS' menus.\\
    
    \begin{code}
    \begin{inicode}
[General]
Tdcs=4
ScanID=$scanid
HV=$HV
RunType=$runtype
MaxTriggers=$maxtriggers
Beam=$beam
[VMEInterface]
Type=V1718
BaseAddress=0xFF0000
Name=VmeInterface
[TDC0]
Type=V1190A
BaseAddress=0x00000000
Name=Tdc0
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDC1]
Type=V1190A
BaseAddress=0x11110000
Name=Tdc1
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDC2]
Type=V1190A
BaseAddress=0x22220000
Name=Tdc2
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDC3]
Type=V1190A
BaseAddress=0x44440000
Name=Tdc3
StatusA00-15=1
StatusA16-31=1
StatusB00-15=1
StatusB16-31=1
StatusC00-15=1
StatusC16-31=1
StatusD00-15=1
StatusD16-31=1
[TDCSettings]
TriggerExtraSearchMargin=0
TriggerRejectMargin=0
TriggerTimeSubstraction=0b1
TdcDetectionMode=0b01
TdcResolution=0b10
TdcDeadTime=0b00
TdcHeadTrailer=0b1
TdcEventSize=0b1001
TdcTestMode=0b0
BLTMode=1
	\end{inicode}
	\captionof{listing}{INI configuration file template for 4 TDCs. In section \iniinline{[General]}, the number of TDCs is explicited and information about the ongoing run is given. Then, there are sections for each and every VME modules. There buffer addresses are given and for the TDCs, the list of channels to enable is given. Finally, in section \iniinline{[TDCSettings]}, a part of the TDC settings are given.}
	\label{ini:INIFile}
	\vspace{5mm}
	\end{code}
	
	In order to retreive the information of the configuration file, the object \cppinline{IniFile} has been developped to provide an INI parser, presented in Source Code~\ref{cpp:inifile}. It contains private methods returning a boolean to check the type of line written in the file, whether a comment, a group header or a key line (\cppinline{IniFile::CheckIfComment()}, \cppinline{IniFile::CheckIfGroup()} and \cppinline{IniFile::CheckIfToken()}). The key may sometimes be referred to as \textit{token} in the source code. Moreover, the private element \cppinline{FileData} is a map of \cppinline{const string} to \cppinline{string} that allows to store the data contained inside the configuration file via the public method \cppinline{IniFile::GetFileData()} following the formatting (see method \cppinline{IniFile::Read()}):\\
	
	\begin{cppcode}
 string group, token, value;
 // Get the field values for the 3 strings.
 // Then concatenate group and token together as a single string
 // with a dot separation.
 token = group + "." + token;
 FileData[token] = value;
	\end{cppcode}
	\vspace{5mm}
	
	More methods have been written to translate the different keys into the right variable format when used by the DAQ. For example, to get a \cppinline{float} value out of the configuration file data, knowing the group and the key needed, the method \cppinline{IniFile::floatType()} can be used. It takes 3 arguments being the group name and key name (both \cppinline{string}), and a default \cppinline{float} value used as exception in the case the expected combination of group and key cannot be found in the configuration file. This default value is then used and the DAQ continues on working after sending an alert in the log file for further debugging.\\
	
	\begin{code}
	\begin{cppcode}
typedef map< const string, string > IniFileData;

class IniFile{
    private:
        bool        CheckIfComment(string line);
        bool        CheckIfGroup(string line,string& group);
        bool        CheckIfToken(string line,string& key,string& value);
        string      FileName;
        IniFileData FileData;
        int         Error;

    public:
        IniFile();
        IniFile(string filename);
        virtual    ~IniFile();

        // Basic file operations
        void        SetFileName(string filename);
        int         Read();
        int         Write();
        IniFileData GetFileData();

        // Data readout methods
        Data32      addressType (string groupname, string keyname, Data32 defaultvalue);
        long        intType     (string groupname, string keyname, long defaultvalue);
        long long   longType    (string groupname, string keyname, long long defaultvalue );
        string      stringType  (string groupname, string keyname, string defaultvalue );
        float       floatType   (string groupname, string keyname, float defaultvalue );

        // Error methods
        string      GetErrorMsg();
};
	\end{cppcode}
	\captionof{listing}{Description of C++ object \cppinline{IniFile} used as a parser for INI file format.}
	\label{cpp:inifile}
	\vspace{5mm}
	\end{code}

    \subsection{WebDCS/DAQ intercommunication}
    \label{app1:ssec:dcsdaqcomm}
    
    When shifters send instructions to the DAQ via the configuration file, it is the webDCS itself that gives the start command to the DAQ and then the 2 softwares use inter-process communication through file to synchronise themselves. This communication file is represented by the variable \cppinline{const string __runstatuspath}.\\
    On one side, the webDCS sends commands or status that are readout by the DAQ:
    \begin{itemize}
    	\item[•] \textinline{INIT}, status sent when launching a scan and read via function \cppinline{CtrlRunStatus(...)},
    	\item[•] \textinline{START}, command to start data taking and read via function \cppinline{CheckSTART()},
    	\item[•] \textinline{STOP}, command to stop data taking at the end of the scan and read via function \cppinline{CheckSTOP()}, and
    	\item[•] \textinline{KILL}, command to kill data taking sent by user and read via function \cppinline{CheckKILL()}
    \end{itemize}
and on the other, the DAQ sends status that are controled by the webDCS:
    \begin{itemize}
    	\item[•] \textinline{DAQ_RDY}, sent with \cppinline{SendDAQReady()} to signify that the DAQ is ready to receive commands from the webDCS,
    	\item[•] \textinline{RUNNING}, sent with \cppinline{SendDAQRunning()} to signify that the DAQ is taking data,
    	\item[•] \textinline{DAQ_ERR}, sent with \cppinline{SendDAQError()} to signify that the DAQ didn't receive the expected command from the webDCS or that the launch command didn't have the right number of arguments,
    	\item[•] \textinline{RD_ERR}, sent when the DAQ wasn't able to read the communication file, and
    	\item[•] \textinline{WR_ERR}, sent when the DAQ wasn't able to write into the communication file.
    \end{itemize}
    
    \subsection{Example of inter-process communication cycle}
    \label{app1:ssec:commex}
    
    Under normal conditions, the webDCS and the DAQ processes exchange commands and status via the file hosted at the address \cppinline{__runstatuspath}, as explained in subsection~\ref{app1:ssec:dcsdaqcomm}. An example of cycle is given in Table~\ref{tab:intercom}. In this example, the steps 3 to 5 are repeated as long as the webDCS tells the DAQ to take data. A data taking cycle is the equivalent as what is called a \textit{Scan} in GIF++ jargon, referring to a set a runs with several HV steps. Each repetition of steps 3 to 5 is then equivalent to a single \textit{Run}.\\
    
    At any moment during the data taking, for any reason, the shifter can decide that the data taking needs to be stopped before it reached the end of the scheduled cycle. Thus at any moment on the cycle, the content of the inter-process communication file will be changed to \textinline{KILL} and the DAQ will shut down right away. The DAQ checks for \textinline{KILL} signals every 5s after the TDCs configuration is over. So far, the function \cppinline{CheckKILL()} has been used only inside of the data taking loop of method \cppinline{DataReader::Run()} and thus, if the shifter decides to KILL the data taking during the TDC configuration phase or the HV ramping in between 2 HV steps, the DAQ will not be stopped smoothly and a \textit{force kill} command will be sent to stop the DAQ process that is still awake on the computer. Improvements can be brought on this part of the software to make sure that the DAQ can safely shutdown at any moment.\\
    
    \begin{table}
	    \begin{tabular}{|c|c|c|c|}
	    	\hline
	    	step & actions of webDCS & status of DAQ & \cppinline{__runstatuspath}\\
	    	\hline
	    	1 & launch DAQ & readout of IniFfile & \textinline{INIT}\\
	    	 & ramp voltages & configuration of TDCs & \\
	    	 & ramping over & & \\
	    	 & wait for currents stabilization & & \\
	    	\hline
	    	2 &  & configuration done & \textinline{DAQ_RDY}\\
	    	 &  & send DAQ ready & \\
	    	 &  & wait for \textinline{START} signal & \\
	    	\hline
	    	3 & waiting time over & & \textinline{START}\\
	    	 & send \textinline{START} & & \\
	    	\hline
	    	4 & wait for run to end & data taking ongoing & \textinline{RUNNING}\\
	    	 & monitor DAQ run status & check for \textinline{KILL} signal & \\
	    	\hline
	    	5 &  & run over & \textinline{DAQ_RDY}\\
	    	 &  & send \textinline{DAQ_RDY} & \\
	    	 &  & wait for next DCS signal & \\
	    	\hline
	    	6 & ramp voltages &  & \textinline{DAQ_RDY}\\
	    	 & ramping over &  & \\
	    	 & wait for currents stabilization &  & \\
	    	\hline
	    	3 & waiting time over & & \textinline{START}\\
	    	 & send \textinline{START} & & \\
	    	\hline
	    	4 & wait for run to end & update IniFile information & \textinline{RUNNING}\\
	    	 & monitor DAQ run status & data taking ongoing & \\
	    	 &  & check for \textinline{KILL} signal & \\
	    	\hline
	    	5 &  & run over & \textinline{DAQ_RDY}\\
	    	 &  & send \textinline{DAQ_RDY} & \\
	    	 &  & wait for next DCS signal & \\
	    	\hline
	    	7 & send command \textinline{STOP} & DAQ shuts down & \textinline{STOP}\\
	    	\hline
	    \end{tabular}
	    \caption{\label{tab:intercom} Inter-process communication cycles in between the webDCS and the DAQ through file string signals.}
    \end{table}

\section{Software export}
\label{app1:sec:export}
	
	In section \ref{app1:sec:usage} was discussed the fact that the DAQ as written in its last version is not a standalone software. It is possible to make it a standalone program that could be adapted to any VME setup using V1190A and V1718 modules by creating a GUI for the software or by printing the log messages that are normally printed in the webDCS through the log file, directly into the terminal. This method was used by the DAQ up to version 3.0 moment where the webDCS was completed. Also, it is possible to check branches of DAQ v2.X to have example of communication through a terminal.\\
	
	DAQ v2.X is nontheless limited in it's possibilities and requires a lot of offline manual interventions from the users. Indeed, there is no communication of the software with the detectors' power supply system that would allow for a user a predefine a list of voltages to operate the detectors at and loop over to take data without any further manual intervention. In v2.X, the data is taken for a single detector setting and at the end of each run, the softwares asks the user if he intends on taking more runs. If so, the software invites the user to set the operating voltages accordingly to what is necessary and to manual update the configuration file in consequence. This working mode can be a very first approach before an evolution and has been successfuly used by colleagues from different collaborations.\\
	
	For a more robust operation, it is recommanded to develop a GUI or a web application to interface the DAQ. Moreover, to limit the amount of manual interventions, and thus the probability to make mistakes, it is also recommanded to add an extra feature into the DAQ by installing the \href{http://caen.it/csite/CaenProd.jsp?idmod=835&parent=42}{HV Wrapper library} provided by CAEN of which an example of use in a similar DAQ software developped by a master student of UGent, and called \href{https://github.ugent.be/favassch/TinyDAQ}{TinyDAQ}, is provided on UGent's github. Then, this HV Wrapper will help you communicating with and give instructions to a CAEN HV powered crate and can be added into the DAQ at the same level where the communication with the user was made in DAQ v2.X. In case you are using another kind of power system for your detectors, it is stringly adviced to use HV modules or crates that can be remotely controled via a using C++ libraries.\\

\clearpage{\pagestyle{empty}\cleardoublepage}
